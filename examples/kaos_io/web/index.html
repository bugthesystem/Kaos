<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaos.io - Multiplayer Game Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .logo {
            font-size: 72px;
            font-weight: 900;
            background: linear-gradient(45deg, #4ECDC4, #44A08D, #093637);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 0 60px rgba(78, 205, 196, 0.3);
        }

        .subtitle {
            color: #666;
            font-size: 16px;
            margin-bottom: 40px;
        }

        .input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #nameInput {
            padding: 15px 25px;
            font-size: 18px;
            border: 2px solid #333;
            border-radius: 50px;
            background: #1a1a1a;
            color: #fff;
            width: 250px;
            outline: none;
            transition: border-color 0.3s;
        }

        #nameInput:focus {
            border-color: #4ECDC4;
        }

        #playBtn {
            padding: 15px 40px;
            font-size: 18px;
            font-weight: 600;
            border: none;
            border-radius: 50px;
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #playBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(78, 205, 196, 0.4);
        }

        .instructions {
            color: #555;
            font-size: 14px;
            margin-top: 30px;
            text-align: center;
            line-height: 1.8;
        }

        .instructions kbd {
            background: #222;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
        }

        .powered-by {
            position: absolute;
            bottom: 30px;
            color: #333;
            font-size: 14px;
        }

        .powered-by a {
            color: #4ECDC4;
            text-decoration: none;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            z-index: 50;
            pointer-events: none;
        }

        .stat {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            margin-bottom: 8px;
            backdrop-filter: blur(10px);
        }

        .stat-value {
            font-weight: 600;
            color: #4ECDC4;
        }

        /* Leaderboard */
        #leaderboard {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 20px;
            border-radius: 15px;
            color: #fff;
            font-size: 14px;
            z-index: 50;
            min-width: 200px;
            backdrop-filter: blur(10px);
        }

        #leaderboard h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #FFD700;
        }

        .lb-entry {
            padding: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .lb-entry.me {
            color: #4ECDC4;
            font-weight: 600;
        }

        .lb-rank {
            width: 25px;
        }

        .lb-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .lb-score {
            width: 60px;
            text-align: right;
        }

        /* Minimap */
        #minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #333;
            border-radius: 10px;
            z-index: 50;
        }

        /* Messages */
        #messages {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            z-index: 50;
        }

        .message {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 10px;
            margin-top: 5px;
            animation: fadeIn 0.3s ease-out;
        }

        .message.kill {
            border-left: 3px solid #FF6B6B;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Mobile controls */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
        }

        @media (max-width: 768px) {
            #mobileControls {
                display: flex;
                gap: 20px;
            }

            .mobile-btn {
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: rgba(78, 205, 196, 0.3);
                border: 2px solid #4ECDC4;
                color: #fff;
                font-size: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <div class="logo">KAOS.IO</div>
        <div class="subtitle">Multiplayer Arena Game ‚Ä¢ Powered by KaosNet</div>

        <div class="input-container">
            <input type="text" id="nameInput" placeholder="Enter your name" maxlength="15" autofocus>
            <button id="playBtn">PLAY</button>
        </div>

        <div class="instructions">
            <strong>How to Play:</strong><br>
            Move your mouse to control direction<br>
            <kbd>Space</kbd> Split ‚Ä¢ <kbd>W</kbd> Eject mass<br>
            Eat food and smaller players to grow!
        </div>

        <div class="powered-by">
            Powered by <a href="https://github.com/anthropics/kaos" target="_blank">KaosNet</a> ‚Ä¢
            An Agar.io-style demo
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud" style="display: none;">
        <div class="stat">Mass: <span class="stat-value" id="massValue">0</span></div>
        <div class="stat">Score: <span class="stat-value" id="scoreValue">0</span></div>
    </div>

    <!-- Leaderboard -->
    <div id="leaderboard" style="display: none;">
        <h3>üèÜ Leaderboard</h3>
        <div id="leaderboardList"></div>
    </div>

    <!-- Minimap -->
    <canvas id="minimap" style="display: none;"></canvas>

    <!-- Messages -->
    <div id="messages"></div>

    <!-- Mobile Controls -->
    <div id="mobileControls">
        <button class="mobile-btn" id="splitBtn">‚úÇÔ∏è</button>
        <button class="mobile-btn" id="ejectBtn">üí®</button>
    </div>

    <script>
        // Game Constants
        const WORLD_WIDTH = 2000;
        const WORLD_HEIGHT = 2000;
        const BASE_SPEED = 200;
        const BASE_RADIUS = 20;
        const FOOD_COUNT = 200;
        const FOOD_RADIUS = 8;
        const FOOD_VALUE = 5;

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const minimapCtx = minimap.getContext('2d');

        // Game state
        let gameRunning = false;
        let myPlayer = null;
        let players = [];
        let food = [];
        let leaderboard = [];
        let mouseX = 0;
        let mouseY = 0;
        let cameraX = WORLD_WIDTH / 2;
        let cameraY = WORLD_HEIGHT / 2;
        let cameraZoom = 1;
        let messages = [];

        // Colors
        const COLORS = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
            '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
            '#F8B500', '#FF6F61', '#6B5B95', '#88B04B', '#F7CAC9'
        ];

        function randomColor() {
            return COLORS[Math.floor(Math.random() * COLORS.length)];
        }

        function massToRadius(mass) {
            return Math.sqrt(mass / Math.PI) * 4;
        }

        function radiusToMass(radius) {
            return Math.PI * Math.pow(radius / 4, 2);
        }

        // Initialize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Initialize food
        function spawnFood(count) {
            for (let i = 0; i < count; i++) {
                food.push({
                    id: food.length,
                    x: Math.random() * (WORLD_WIDTH - 100) + 50,
                    y: Math.random() * (WORLD_HEIGHT - 100) + 50,
                    radius: FOOD_RADIUS,
                    color: randomColor()
                });
            }
        }

        // Add AI players for demo
        function addAIPlayers(count) {
            for (let i = 0; i < count; i++) {
                const aiPlayer = {
                    id: 'ai_' + i,
                    name: ['Blob', 'Chomper', 'Hungry', 'Gamer', 'Pro', 'Noob', 'Legend'][Math.floor(Math.random() * 7)] + Math.floor(Math.random() * 1000),
                    x: Math.random() * (WORLD_WIDTH - 200) + 100,
                    y: Math.random() * (WORLD_HEIGHT - 200) + 100,
                    targetX: Math.random() * WORLD_WIDTH,
                    targetY: Math.random() * WORLD_HEIGHT,
                    mass: radiusToMass(BASE_RADIUS) * (0.5 + Math.random() * 2),
                    color: randomColor(),
                    score: 0,
                    alive: true,
                    isAI: true,
                    aiTimer: 0
                };
                players.push(aiPlayer);
            }
        }

        // Start game
        function startGame(playerName) {
            const startScreen = document.getElementById('startScreen');
            startScreen.style.display = 'none';

            document.getElementById('hud').style.display = 'block';
            document.getElementById('leaderboard').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';

            // Create player
            myPlayer = {
                id: 'local',
                name: playerName || 'Player',
                x: WORLD_WIDTH / 2,
                y: WORLD_HEIGHT / 2,
                mass: radiusToMass(BASE_RADIUS),
                color: '#4ECDC4',
                score: 0,
                alive: true
            };
            players = [myPlayer];

            // Spawn food and AI
            food = [];
            spawnFood(FOOD_COUNT);
            addAIPlayers(8);

            cameraX = myPlayer.x;
            cameraY = myPlayer.y;

            gameRunning = true;
            addMessage('Welcome to Kaos.io!', 'info');
            addMessage('Eat food and smaller players to grow', 'info');

            requestAnimationFrame(gameLoop);
        }

        // Add message
        function addMessage(text, type = 'info') {
            messages.push({ text, type, time: Date.now() });
            if (messages.length > 5) messages.shift();
            updateMessagesUI();
        }

        function updateMessagesUI() {
            const container = document.getElementById('messages');
            container.innerHTML = messages
                .filter(m => Date.now() - m.time < 5000)
                .map(m => `<div class="message ${m.type}">${m.text}</div>`)
                .join('');
        }

        // Update leaderboard
        function updateLeaderboard() {
            const sorted = players
                .filter(p => p.alive)
                .sort((a, b) => b.mass - a.mass)
                .slice(0, 10);

            const list = document.getElementById('leaderboardList');
            list.innerHTML = sorted.map((p, i) => {
                const isMe = p.id === 'local';
                return `<div class="lb-entry ${isMe ? 'me' : ''}">
                    <span class="lb-rank">${i + 1}.</span>
                    <span class="lb-name">${p.name}</span>
                    <span class="lb-score">${Math.floor(p.mass)}</span>
                </div>`;
            }).join('');
        }

        // Update HUD
        function updateHUD() {
            if (myPlayer) {
                document.getElementById('massValue').textContent = Math.floor(myPlayer.mass);
                document.getElementById('scoreValue').textContent = myPlayer.score;
            }
        }

        // Mouse handling
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        });

        // Keyboard handling
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameRunning) {
                // Split (simplified - just add some mass as food)
                if (myPlayer && myPlayer.mass > radiusToMass(BASE_RADIUS) * 2) {
                    myPlayer.mass *= 0.8;
                    addMessage('Split!', 'info');
                }
            }
            if (e.code === 'KeyW' && gameRunning) {
                // Eject mass
                if (myPlayer && myPlayer.mass > radiusToMass(BASE_RADIUS) * 1.5) {
                    myPlayer.mass -= FOOD_VALUE * 2;
                    const radius = massToRadius(myPlayer.mass);
                    const dx = mouseX - canvas.width / 2;
                    const dy = mouseY - canvas.height / 2;
                    const len = Math.sqrt(dx * dx + dy * dy) || 1;
                    food.push({
                        id: food.length,
                        x: myPlayer.x + (dx / len) * (radius + 20),
                        y: myPlayer.y + (dy / len) * (radius + 20),
                        radius: FOOD_RADIUS * 1.5,
                        color: myPlayer.color
                    });
                }
            }
        });

        // Game loop
        let lastTime = performance.now();

        function gameLoop(currentTime) {
            if (!gameRunning) return;

            const dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            update(dt);
            render();
            renderMinimap();
            updateHUD();
            updateLeaderboard();

            requestAnimationFrame(gameLoop);
        }

        // Update game state
        function update(dt) {
            if (!myPlayer || !myPlayer.alive) return;

            // Calculate target position in world coordinates
            const targetX = cameraX + (mouseX - canvas.width / 2) / cameraZoom;
            const targetY = cameraY + (mouseY - canvas.height / 2) / cameraZoom;

            // Move player towards mouse
            const dx = targetX - myPlayer.x;
            const dy = targetY - myPlayer.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            const radius = massToRadius(myPlayer.mass);
            const speed = BASE_SPEED * (BASE_RADIUS / (radius * 0.5 + BASE_RADIUS * 0.5));

            if (dist > 5) {
                myPlayer.x += (dx / dist) * speed * dt;
                myPlayer.y += (dy / dist) * speed * dt;
            }

            // Clamp to world
            myPlayer.x = Math.max(radius, Math.min(WORLD_WIDTH - radius, myPlayer.x));
            myPlayer.y = Math.max(radius, Math.min(WORLD_HEIGHT - radius, myPlayer.y));

            // Update camera
            cameraX += (myPlayer.x - cameraX) * 0.1;
            cameraY += (myPlayer.y - cameraY) * 0.1;
            cameraZoom = Math.max(0.5, 1 - (radius - BASE_RADIUS) / 200);

            // Mass decay
            if (myPlayer.mass > radiusToMass(BASE_RADIUS * 2)) {
                myPlayer.mass *= (1 - 0.001 * dt);
            }

            // Check food collisions
            for (let i = food.length - 1; i >= 0; i--) {
                const f = food[i];
                const fdist = Math.sqrt(Math.pow(myPlayer.x - f.x, 2) + Math.pow(myPlayer.y - f.y, 2));
                if (fdist < radius - f.radius * 0.5) {
                    myPlayer.mass += FOOD_VALUE;
                    myPlayer.score++;
                    food.splice(i, 1);
                }
            }

            // Update AI players
            for (const ai of players) {
                if (!ai.isAI || !ai.alive) continue;

                // AI decision making
                ai.aiTimer -= dt;
                if (ai.aiTimer <= 0) {
                    ai.aiTimer = 1 + Math.random() * 2;

                    // Find nearest food or smaller player
                    let bestTarget = null;
                    let bestDist = Infinity;

                    for (const f of food) {
                        const d = Math.sqrt(Math.pow(ai.x - f.x, 2) + Math.pow(ai.y - f.y, 2));
                        if (d < bestDist) {
                            bestDist = d;
                            bestTarget = { x: f.x, y: f.y };
                        }
                    }

                    // Sometimes chase smaller players
                    if (Math.random() < 0.3) {
                        for (const p of players) {
                            if (p.id !== ai.id && p.alive && p.mass < ai.mass * 0.9) {
                                const d = Math.sqrt(Math.pow(ai.x - p.x, 2) + Math.pow(ai.y - p.y, 2));
                                if (d < bestDist) {
                                    bestDist = d;
                                    bestTarget = { x: p.x, y: p.y };
                                }
                            }
                        }
                    }

                    // Flee from larger players
                    for (const p of players) {
                        if (p.id !== ai.id && p.alive && p.mass > ai.mass * 1.2) {
                            const d = Math.sqrt(Math.pow(ai.x - p.x, 2) + Math.pow(ai.y - p.y, 2));
                            if (d < 300) {
                                ai.targetX = ai.x - (p.x - ai.x);
                                ai.targetY = ai.y - (p.y - ai.y);
                                bestTarget = null;
                                break;
                            }
                        }
                    }

                    if (bestTarget) {
                        ai.targetX = bestTarget.x;
                        ai.targetY = bestTarget.y;
                    }
                }

                // Move AI
                const aidx = ai.targetX - ai.x;
                const aidy = ai.targetY - ai.y;
                const aidist = Math.sqrt(aidx * aidx + aidy * aidy);
                const airadius = massToRadius(ai.mass);
                const aispeed = BASE_SPEED * (BASE_RADIUS / (airadius * 0.5 + BASE_RADIUS * 0.5));

                if (aidist > 5) {
                    ai.x += (aidx / aidist) * aispeed * dt;
                    ai.y += (aidy / aidist) * aispeed * dt;
                }

                ai.x = Math.max(airadius, Math.min(WORLD_WIDTH - airadius, ai.x));
                ai.y = Math.max(airadius, Math.min(WORLD_HEIGHT - airadius, ai.y));

                // AI eats food
                for (let i = food.length - 1; i >= 0; i--) {
                    const f = food[i];
                    const fdist = Math.sqrt(Math.pow(ai.x - f.x, 2) + Math.pow(ai.y - f.y, 2));
                    if (fdist < airadius - f.radius * 0.5) {
                        ai.mass += FOOD_VALUE;
                        ai.score++;
                        food.splice(i, 1);
                    }
                }

                // AI mass decay
                if (ai.mass > radiusToMass(BASE_RADIUS * 2)) {
                    ai.mass *= (1 - 0.001 * dt);
                }
            }

            // Player-player collisions
            for (let i = 0; i < players.length; i++) {
                const p1 = players[i];
                if (!p1.alive) continue;
                const r1 = massToRadius(p1.mass);

                for (let j = i + 1; j < players.length; j++) {
                    const p2 = players[j];
                    if (!p2.alive) continue;
                    const r2 = massToRadius(p2.mass);

                    const pdist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

                    if (pdist < r1 - r2 * 0.4 && p1.mass > p2.mass * 1.1) {
                        p1.mass += p2.mass * 0.8;
                        p1.score += 10;
                        p2.alive = false;
                        addMessage(`${p1.name} ate ${p2.name}!`, 'kill');

                        if (p2.id === 'local') {
                            setTimeout(() => respawnPlayer(), 2000);
                        }
                    } else if (pdist < r2 - r1 * 0.4 && p2.mass > p1.mass * 1.1) {
                        p2.mass += p1.mass * 0.8;
                        p2.score += 10;
                        p1.alive = false;
                        addMessage(`${p2.name} ate ${p1.name}!`, 'kill');

                        if (p1.id === 'local') {
                            setTimeout(() => respawnPlayer(), 2000);
                        }
                    }
                }
            }

            // Respawn food
            while (food.length < FOOD_COUNT) {
                food.push({
                    id: food.length,
                    x: Math.random() * (WORLD_WIDTH - 100) + 50,
                    y: Math.random() * (WORLD_HEIGHT - 100) + 50,
                    radius: FOOD_RADIUS,
                    color: randomColor()
                });
            }

            // Respawn dead AI
            for (const ai of players) {
                if (ai.isAI && !ai.alive) {
                    ai.x = Math.random() * (WORLD_WIDTH - 200) + 100;
                    ai.y = Math.random() * (WORLD_HEIGHT - 200) + 100;
                    ai.mass = radiusToMass(BASE_RADIUS);
                    ai.alive = true;
                }
            }
        }

        function respawnPlayer() {
            if (myPlayer) {
                myPlayer.x = Math.random() * (WORLD_WIDTH - 200) + 100;
                myPlayer.y = Math.random() * (WORLD_HEIGHT - 200) + 100;
                myPlayer.mass = radiusToMass(BASE_RADIUS);
                myPlayer.alive = true;
                addMessage('Respawned!', 'info');
            }
        }

        // Render game
        function render() {
            // Clear canvas
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();

            // Apply camera transform
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(cameraZoom, cameraZoom);
            ctx.translate(-cameraX, -cameraY);

            // Draw grid
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x <= WORLD_WIDTH; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, WORLD_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y <= WORLD_HEIGHT; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(WORLD_WIDTH, y);
                ctx.stroke();
            }

            // Draw world border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

            // Draw food
            for (const f of food) {
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
                ctx.fillStyle = f.color;
                ctx.fill();
            }

            // Draw players (sorted by size, smallest first)
            const sortedPlayers = [...players].filter(p => p.alive).sort((a, b) => a.mass - b.mass);

            for (const p of sortedPlayers) {
                const radius = massToRadius(p.mass);

                // Glow effect
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius * 1.2);
                gradient.addColorStop(0, p.color);
                gradient.addColorStop(0.8, p.color);
                gradient.addColorStop(1, 'transparent');

                ctx.beginPath();
                ctx.arc(p.x, p.y, radius * 1.1, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Main body
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();

                // Border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Name
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${Math.max(14, radius / 2)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.name, p.x, p.y - 5);

                // Mass
                ctx.font = `${Math.max(10, radius / 3)}px sans-serif`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillText(Math.floor(p.mass), p.x, p.y + radius / 4);
            }

            ctx.restore();
        }

        // Render minimap
        function renderMinimap() {
            const mmWidth = 150;
            const mmHeight = 150;
            minimap.width = mmWidth;
            minimap.height = mmHeight;

            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            minimapCtx.fillRect(0, 0, mmWidth, mmHeight);

            const scale = mmWidth / WORLD_WIDTH;

            // Draw players on minimap
            for (const p of players) {
                if (!p.alive) continue;
                const x = p.x * scale;
                const y = p.y * scale;
                const radius = Math.max(2, massToRadius(p.mass) * scale);

                minimapCtx.beginPath();
                minimapCtx.arc(x, y, radius, 0, Math.PI * 2);
                minimapCtx.fillStyle = p.id === 'local' ? '#4ECDC4' : p.color;
                minimapCtx.fill();
            }

            // Draw viewport
            const viewLeft = (cameraX - canvas.width / 2 / cameraZoom) * scale;
            const viewTop = (cameraY - canvas.height / 2 / cameraZoom) * scale;
            const viewWidth = (canvas.width / cameraZoom) * scale;
            const viewHeight = (canvas.height / cameraZoom) * scale;

            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(viewLeft, viewTop, viewWidth, viewHeight);
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            const name = document.getElementById('nameInput').value.trim() || 'Player';
            startGame(name);
        });

        document.getElementById('nameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const name = document.getElementById('nameInput').value.trim() || 'Player';
                startGame(name);
            }
        });

        // Mobile controls
        document.getElementById('splitBtn')?.addEventListener('click', () => {
            if (myPlayer && myPlayer.mass > radiusToMass(BASE_RADIUS) * 2) {
                myPlayer.mass *= 0.8;
            }
        });
    </script>
</body>
</html>
