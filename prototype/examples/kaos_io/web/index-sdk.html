<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaos.io - Multiplayer Game Demo (SDK Version)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a0a; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; }
        #gameCanvas { display: block; position: absolute; top: 0; left: 0; }

        /* Start Screen */
        #startScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }
        .logo {
            width: 120px; height: 120px; margin-bottom: 20px;
            filter: drop-shadow(0 0 30px rgba(0, 212, 255, 0.5));
        }
        .logo-text {
            font-size: 48px; font-weight: 900;
            background: linear-gradient(45deg, #00d4ff, #00ff88, #006080);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            margin-bottom: 10px; text-shadow: 0 0 60px rgba(0, 212, 255, 0.3);
        }
        .subtitle { color: #666; font-size: 16px; margin-bottom: 40px; }
        .input-container { display: flex; gap: 10px; margin-bottom: 20px; }
        #nameInput {
            padding: 15px 25px; font-size: 18px; border: 2px solid #333; border-radius: 50px;
            background: #1a1a1a; color: #fff; width: 250px; outline: none; transition: border-color 0.3s;
        }
        #nameInput:focus { border-color: #00d4ff; }
        #playBtn {
            padding: 15px 40px; font-size: 18px; font-weight: 600; border: none; border-radius: 50px;
            background: linear-gradient(45deg, #00d4ff, #00ff88); color: #000; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #playBtn:hover { transform: scale(1.05); box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4); }
        #playBtn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .server-status { color: #666; font-size: 14px; margin-bottom: 20px; }
        .server-status.connected { color: #00d4ff; }
        .server-status.error { color: #FF6B6B; }
        .instructions { color: #555; font-size: 14px; margin-top: 30px; text-align: center; line-height: 1.8; }
        .instructions kbd { background: #222; padding: 4px 8px; border-radius: 4px; font-family: monospace; }
        .powered-by { position: absolute; bottom: 30px; color: #333; font-size: 14px; }
        .powered-by a { color: #00d4ff; text-decoration: none; }
        .sdk-badge { background: #00d4ff; color: #000; padding: 4px 10px; border-radius: 4px; font-size: 12px; margin-left: 10px; }

        /* HUD */
        #hud { position: fixed; top: 20px; left: 20px; color: #fff; font-size: 14px; z-index: 50; pointer-events: none; }
        .stat { background: rgba(0,0,0,0.5); padding: 8px 15px; border-radius: 20px; margin-bottom: 8px; backdrop-filter: blur(10px); }
        .stat-value { font-weight: 600; color: #00d4ff; }

        /* Leaderboard */
        #leaderboard {
            position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.6);
            padding: 15px 20px; border-radius: 15px; color: #fff; font-size: 14px;
            z-index: 50; min-width: 220px; backdrop-filter: blur(10px);
        }
        #leaderboard h3 { font-size: 16px; margin-bottom: 10px; color: #FFD700; }
        .lb-section { margin-bottom: 15px; }
        .lb-section-title { font-size: 12px; color: #888; margin-bottom: 5px; text-transform: uppercase; }
        .lb-entry { padding: 4px 0; display: flex; justify-content: space-between; }
        .lb-entry.me { color: #00d4ff; font-weight: 600; }
        .lb-rank { width: 25px; }
        .lb-name { flex: 1; overflow: hidden; text-overflow: ellipsis; }
        .lb-score { width: 60px; text-align: right; }
        .lb-kills { width: 40px; text-align: right; color: #FF6B6B; }

        /* Minimap */
        #minimap {
            position: fixed; bottom: 20px; right: 20px; width: 150px; height: 150px;
            background: rgba(0,0,0,0.5); border: 2px solid #333; border-radius: 10px; z-index: 50;
        }

        /* Messages */
        #messages { position: fixed; bottom: 20px; left: 20px; color: #fff; font-size: 14px; z-index: 50; }
        .message { background: rgba(0,0,0,0.5); padding: 8px 15px; border-radius: 10px; margin-top: 5px; animation: fadeIn 0.3s ease-out; }
        .message.kill { border-left: 3px solid #FF6B6B; }
        .message.info { border-left: 3px solid #4ECDC4; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <img src="logo.svg" alt="KaosNet" class="logo">
        <div class="logo-text">KAOS.IO</div>
        <div class="subtitle">Multiplayer Arena ‚Ä¢ Powered by KaosNet <span class="sdk-badge">SDK</span></div>
        <div class="server-status" id="serverStatus">Connecting to server...</div>
        <div class="input-container">
            <input type="text" id="nameInput" placeholder="Enter your name" maxlength="15" autofocus>
            <button id="playBtn" disabled>PLAY</button>
        </div>
        <div class="instructions">
            <strong>How to Play:</strong><br>
            Move your mouse to control direction<br>
            Eat food and smaller players to grow!<br><br>
            <strong>KaosNet SDK Features:</strong> Device Auth ‚Ä¢ Auto-Reconnect ‚Ä¢ Leaderboards
        </div>
        <div class="powered-by">
            Powered by <a href="#">KaosNet</a> Game Server + SDK
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud" style="display: none;">
        <div class="stat">Score: <span class="stat-value" id="scoreValue">0</span></div>
        <div class="stat">High Score: <span class="stat-value" id="highScoreValue">0</span></div>
        <div class="stat">Kills: <span class="stat-value" id="killsValue">0</span></div>
        <div class="stat" style="font-size: 11px; opacity: 0.7;">
            Net: <span id="netStats">--</span>
        </div>
    </div>

    <!-- Leaderboard -->
    <div id="leaderboard" style="display: none;">
        <h3>üèÜ Leaderboard</h3>
        <div class="lb-section">
            <div class="lb-section-title">Current Game</div>
            <div id="currentLeaderboard"></div>
        </div>
        <div class="lb-section">
            <div class="lb-section-title">All-Time High Scores</div>
            <div id="allTimeLeaderboard"></div>
        </div>
    </div>

    <canvas id="minimap" style="display: none;"></canvas>
    <div id="messages"></div>

    <!-- Load KaosNet SDK -->
    <script src="../../kaosnet-js/dist/index.global.js"></script>

    <script>
        // ========================================================================
        // KaosNet SDK Integration
        // ========================================================================
        // This example uses the KaosNet SDK for:
        // 1. Device authentication
        // 2. WebSocket connection with auto-reconnect
        // 3. Clean API for sending/receiving game state
        // ========================================================================

        const { KaosClient } = KaosNet;

        // Create KaosNet client (API port)
        const client = new KaosClient(window.location.hostname, 7350);

        // Socket instance (will be created after auth)
        let socket = null;
        let session = null;

        // Generate or retrieve persistent device ID
        function getDeviceId() {
            let deviceId = localStorage.getItem('kaos_device_id');
            if (!deviceId) {
                deviceId = 'device-' + crypto.randomUUID();
                localStorage.setItem('kaos_device_id', deviceId);
            }
            return deviceId;
        }

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const minimapCtx = minimap.getContext('2d');

        // Game state from server
        let gameState = null;
        let myPlayerId = null;
        let playerName = 'Player';
        let connected = false;
        let mouseX = 0, mouseY = 0;
        let cameraX = 1000, cameraY = 1000, cameraZoom = 1;
        let messages = [];

        // === GAFFER ON GAMES: State Interpolation ===
        const stateBuffer = [];
        const STATE_BUFFER_SIZE = 20;
        const INTERPOLATION_DELAY = 100;
        const PREDICTION_ENABLED = true;
        const INTERPOLATION_ENABLED = true;

        // === GAFFER ON GAMES: Client-Side Prediction ===
        let predictedPlayer = null;
        let pendingInputs = [];
        let inputSequence = 0;
        const interpolatedPlayers = new Map();
        let serverTick = 0;

        // Network stats
        let lastServerUpdate = 0;
        let serverUpdateRate = 0;
        let updateCount = 0;
        let bytesReceived = 0;

        // Food colors for dequantization
        const FOOD_COLORS = [
            "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7",
            "#DDA0DD", "#98D8C8", "#F7DC6F", "#BB8FCE", "#85C1E9",
        ];

        function dequantizeState(raw) {
            if (raw.q) {
                const scale = raw.q;
                return {
                    players: raw.p.map(p => ({
                        id: p.id,
                        name: p.name,
                        x: p.x / scale,
                        y: p.y / scale,
                        radius: p.r / scale,
                        color: p.color,
                        score: p.score,
                        high_score: p.high_score,
                        kills: p.kills
                    })),
                    food: raw.f.map(f => ({
                        id: f.id,
                        x: f.x / scale,
                        y: f.y / scale,
                        radius: f.r / scale,
                        color: FOOD_COLORS[f.c] || FOOD_COLORS[0]
                    })),
                    leaderboard: raw.lb,
                    world_width: raw.ww,
                    world_height: raw.wh,
                    tick: raw.t
                };
            }
            return raw;
        }

        function bufferServerState(state) {
            const snapshot = {
                timestamp: performance.now(),
                serverTick: state.tick || serverTick++,
                players: state.players.map(p => ({...p})),
                food: state.food
            };
            stateBuffer.push(snapshot);
            while (stateBuffer.length > STATE_BUFFER_SIZE) {
                stateBuffer.shift();
            }
        }

        function reconcileWithServer(serverState) {
            if (!PREDICTION_ENABLED || !myPlayerId) return;

            const serverPlayer = serverState.players.find(p => p.id === myPlayerId);
            if (!serverPlayer) return;

            const serverInputSeq = serverState.last_input_seq || 0;
            pendingInputs = pendingInputs.filter(input => input.seq > serverInputSeq);

            if (predictedPlayer) {
                predictedPlayer.x = serverPlayer.x;
                predictedPlayer.y = serverPlayer.y;
                predictedPlayer.radius = serverPlayer.radius;
                predictedPlayer.score = serverPlayer.score;
                predictedPlayer.name = serverPlayer.name;
                predictedPlayer.color = serverPlayer.color;

                for (const input of pendingInputs) {
                    applyInput(predictedPlayer, input);
                }
            } else {
                predictedPlayer = {...serverPlayer};
            }
        }

        function applyInput(player, input) {
            if (!player) return;

            const dx = input.target_x - player.x;
            const dy = input.target_y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 5) {
                const speed = Math.max(50, 200 - player.radius);
                const dt = input.dt || 0.05;
                const moveX = (dx / dist) * speed * dt;
                const moveY = (dy / dist) * speed * dt;

                player.x += moveX;
                player.y += moveY;

                if (gameState) {
                    player.x = Math.max(player.radius, Math.min(gameState.world_width - player.radius, player.x));
                    player.y = Math.max(player.radius, Math.min(gameState.world_height - player.radius, player.y));
                }
            }
        }

        function interpolateEntities(renderTime) {
            if (!INTERPOLATION_ENABLED || stateBuffer.length < 2) return;

            const targetTime = renderTime - INTERPOLATION_DELAY;
            let older = null;
            let newer = null;

            for (let i = 0; i < stateBuffer.length - 1; i++) {
                if (stateBuffer[i].timestamp <= targetTime &&
                    stateBuffer[i + 1].timestamp >= targetTime) {
                    older = stateBuffer[i];
                    newer = stateBuffer[i + 1];
                    break;
                }
            }

            if (!older || !newer) {
                const latest = stateBuffer[stateBuffer.length - 1];
                for (const player of latest.players) {
                    if (player.id !== myPlayerId) {
                        interpolatedPlayers.set(player.id, {...player});
                    }
                }
                return;
            }

            const range = newer.timestamp - older.timestamp;
            const t = range > 0 ? (targetTime - older.timestamp) / range : 0;
            const clampedT = Math.max(0, Math.min(1, t));

            for (const newerPlayer of newer.players) {
                if (newerPlayer.id === myPlayerId) continue;

                const olderPlayer = older.players.find(p => p.id === newerPlayer.id);

                if (olderPlayer) {
                    interpolatedPlayers.set(newerPlayer.id, {
                        ...newerPlayer,
                        x: olderPlayer.x + (newerPlayer.x - olderPlayer.x) * clampedT,
                        y: olderPlayer.y + (newerPlayer.y - olderPlayer.y) * clampedT,
                        radius: olderPlayer.radius + (newerPlayer.radius - olderPlayer.radius) * clampedT
                    });
                } else {
                    interpolatedPlayers.set(newerPlayer.id, {...newerPlayer});
                }
            }

            const currentIds = new Set(newer.players.map(p => p.id));
            for (const id of interpolatedPlayers.keys()) {
                if (!currentIds.has(id)) {
                    interpolatedPlayers.delete(id);
                }
            }
        }

        function getRenderedPlayer(player) {
            if (player.id === myPlayerId && PREDICTION_ENABLED && predictedPlayer) {
                return predictedPlayer;
            } else if (player.id !== myPlayerId && INTERPOLATION_ENABLED) {
                return interpolatedPlayers.get(player.id) || player;
            }
            return player;
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ========================================================================
        // SDK-based Connection
        // ========================================================================
        // Note: The kaos_io game server handles auth on WebSocket connect,
        // so we use a simplified flow with just the socket connection.
        // For games that use the full KaosTalk protocol, you would:
        // 1. Call client.authenticateDevice() first
        // 2. Then socket.connect(session) with the returned session
        // ========================================================================
        async function connect() {
            const statusEl = document.getElementById('serverStatus');
            const playBtn = document.getElementById('playBtn');

            statusEl.textContent = 'Connecting to game...';
            statusEl.className = 'server-status';

            try {
                // Create WebSocket connection via SDK
                // For this game, we connect directly without pre-auth
                // The game server authenticates on connection
                socket = client.createSocket();

                // SDK event handlers
                socket.onConnect = () => {
                    connected = true;
                    statusEl.textContent = '‚úì Connected via KaosNet SDK';
                    statusEl.className = 'server-status connected';
                    playBtn.disabled = false;
                };

                socket.onDisconnect = (reason) => {
                    connected = false;
                    statusEl.textContent = 'Disconnected: ' + (reason || 'Connection lost');
                    statusEl.className = 'server-status error';
                    playBtn.disabled = true;
                    // SDK handles auto-reconnect
                };

                socket.onError = (error) => {
                    statusEl.textContent = 'Error: ' + error.message;
                    statusEl.className = 'server-status error';
                };

                // Handle game state broadcasts (via matchState event)
                socket.onMatchState = (state) => {
                    handleGameState(state.data);
                };

                // Connect without a session (game server handles auth on connect)
                // Create a dummy session for the connection
                session = {
                    token: getDeviceId(),
                    userId: getDeviceId(),
                    username: '',
                    expiresAt: Date.now() / 1000 + 3600,
                    created: true,
                };
                await socket.connect(session);

            } catch (error) {
                statusEl.textContent = 'Failed to connect: ' + error.message;
                statusEl.className = 'server-status error';
                // Retry connection
                setTimeout(connect, 3000);
            }
        }

        // Handle incoming game state
        function handleGameState(rawState) {
            try {
                bytesReceived += JSON.stringify(rawState).length;

                gameState = dequantizeState(rawState);

                const now = performance.now();
                if (lastServerUpdate > 0) {
                    const delta = now - lastServerUpdate;
                    serverUpdateRate = 0.9 * serverUpdateRate + 0.1 * (1000 / delta);
                }
                lastServerUpdate = now;
                updateCount++;

                bufferServerState(gameState);
                reconcileWithServer(gameState);
            } catch (e) {
                console.error('Parse error:', e);
            }
        }

        function startGame(name) {
            playerName = name || 'Player';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('leaderboard').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';

            if (gameState && gameState.players.length > 0) {
                myPlayerId = gameState.players[gameState.players.length - 1].id;
            }

            addMessage('Welcome to Kaos.io!', 'info');
            addMessage('Using KaosNet SDK for networking', 'info');

            requestAnimationFrame(gameLoop);
        }

        // Send input using SDK
        function sendInput() {
            if (!socket || !socket.isConnected || !gameState) return;

            const myPlayer = getMyPlayer();
            if (!myPlayer) return;

            const targetX = cameraX + (mouseX - canvas.width / 2) / cameraZoom;
            const targetY = cameraY + (mouseY - canvas.height / 2) / cameraZoom;

            const input = {
                seq: ++inputSequence,
                target_x: targetX,
                target_y: targetY,
                dt: 0.05,
                timestamp: performance.now()
            };

            if (PREDICTION_ENABLED) {
                pendingInputs.push(input);
                while (pendingInputs.length > 60) {
                    pendingInputs.shift();
                }
                if (predictedPlayer) {
                    applyInput(predictedPlayer, input);
                }
            }

            // Use SDK's send method for raw JSON (game-specific protocol)
            socket.send({
                seq: input.seq,
                target_x: targetX,
                target_y: targetY,
                name: playerName
            });
        }

        function getMyPlayer() {
            if (!gameState) return null;
            if (myPlayerId) {
                return gameState.players.find(p => p.id === myPlayerId);
            }
            return gameState.players[gameState.players.length - 1];
        }

        function addMessage(text, type = 'info') {
            messages.push({ text, type, time: Date.now() });
            if (messages.length > 5) messages.shift();
            updateMessagesUI();
        }

        function updateMessagesUI() {
            const container = document.getElementById('messages');
            container.innerHTML = messages
                .filter(m => Date.now() - m.time < 5000)
                .map(m => `<div class="message ${m.type}">${m.text}</div>`)
                .join('');
        }

        function updateLeaderboard() {
            if (!gameState) return;

            const currentSorted = [...gameState.players].sort((a, b) => b.score - a.score).slice(0, 5);
            const currentList = document.getElementById('currentLeaderboard');
            const myPlayer = getMyPlayer();
            currentList.innerHTML = currentSorted.map((p, i) => {
                const isMe = myPlayer && p.id === myPlayer.id;
                return `<div class="lb-entry ${isMe ? 'me' : ''}">
                    <span class="lb-rank">${i + 1}.</span>
                    <span class="lb-name">${p.name}</span>
                    <span class="lb-score">${p.score}</span>
                </div>`;
            }).join('');

            const allTimeList = document.getElementById('allTimeLeaderboard');
            if (gameState.leaderboard && gameState.leaderboard.length > 0) {
                allTimeList.innerHTML = gameState.leaderboard.slice(0, 5).map(entry => {
                    return `<div class="lb-entry">
                        <span class="lb-rank">${entry.rank}.</span>
                        <span class="lb-name">${entry.name}</span>
                        <span class="lb-score">${entry.score}</span>
                        <span class="lb-kills">‚öî${entry.kills}</span>
                    </div>`;
                }).join('');
            } else {
                allTimeList.innerHTML = '<div style="color:#555">No records yet</div>';
            }
        }

        function updateHUD() {
            const myPlayer = getMyPlayer();
            if (myPlayer) {
                const displayPlayer = PREDICTION_ENABLED && predictedPlayer ? predictedPlayer : myPlayer;
                document.getElementById('scoreValue').textContent = displayPlayer.score;
                document.getElementById('highScoreValue').textContent = myPlayer.high_score;
                document.getElementById('killsValue').textContent = myPlayer.kills;
            }

            const kbReceived = (bytesReceived / 1024).toFixed(1);
            const pendingCount = pendingInputs.length;
            const bufferSize = stateBuffer.length;
            document.getElementById('netStats').textContent =
                `${serverUpdateRate.toFixed(0)}Hz | ${kbReceived}KB | P:${pendingCount} B:${bufferSize}`;
        }

        canvas.addEventListener('mousemove', (e) => { mouseX = e.clientX; mouseY = e.clientY; });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        });

        let lastTime = performance.now();
        let inputTimer = 0;

        function gameLoop(currentTime) {
            const dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            inputTimer += dt;
            if (inputTimer > 0.05) {
                sendInput();
                inputTimer = 0;
            }

            interpolateEntities(currentTime);

            const myPlayer = getMyPlayer();
            const cameraTarget = PREDICTION_ENABLED && predictedPlayer ? predictedPlayer : myPlayer;
            if (cameraTarget && gameState) {
                cameraX += (cameraTarget.x - cameraX) * 0.1;
                cameraY += (cameraTarget.y - cameraY) * 0.1;
                cameraZoom = Math.max(0.5, 1 - (cameraTarget.radius - 20) / 200);
            }

            render();
            renderMinimap();
            updateHUD();
            updateLeaderboard();

            requestAnimationFrame(gameLoop);
        }

        function render() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!gameState) {
                ctx.fillStyle = '#333';
                ctx.font = '24px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Waiting for server...', canvas.width / 2, canvas.height / 2);
                return;
            }

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(cameraZoom, cameraZoom);
            ctx.translate(-cameraX, -cameraY);

            const worldWidth = gameState.world_width;
            const worldHeight = gameState.world_height;

            // Grid
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let x = 0; x <= worldWidth; x += 50) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, worldHeight); ctx.stroke();
            }
            for (let y = 0; y <= worldHeight; y += 50) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(worldWidth, y); ctx.stroke();
            }

            // Border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, worldWidth, worldHeight);

            // Food
            for (const f of gameState.food) {
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
                ctx.fillStyle = f.color;
                ctx.fill();
            }

            // Players
            const sortedPlayers = [...gameState.players]
                .map(p => getRenderedPlayer(p))
                .sort((a, b) => a.radius - b.radius);
            const myPlayer = getMyPlayer();

            for (const p of sortedPlayers) {
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius * 1.2);
                gradient.addColorStop(0, p.color);
                gradient.addColorStop(0.8, p.color);
                gradient.addColorStop(1, 'transparent');
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * 1.1, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();

                ctx.strokeStyle = myPlayer && p.id === myPlayer.id ? '#fff' : 'rgba(255,255,255,0.3)';
                ctx.lineWidth = myPlayer && p.id === myPlayer.id ? 4 : 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = `bold ${Math.max(14, p.radius / 2)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.name, p.x, p.y - 5);

                ctx.font = `${Math.max(10, p.radius / 3)}px sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.fillText(p.score, p.x, p.y + p.radius / 4);
            }

            ctx.restore();
        }

        function renderMinimap() {
            if (!gameState) return;

            const mmWidth = 150, mmHeight = 150;
            minimap.width = mmWidth;
            minimap.height = mmHeight;

            minimapCtx.fillStyle = 'rgba(0,0,0,0.5)';
            minimapCtx.fillRect(0, 0, mmWidth, mmHeight);

            const scale = mmWidth / gameState.world_width;
            const myPlayer = getMyPlayer();

            for (const serverPlayer of gameState.players) {
                const p = getRenderedPlayer(serverPlayer);
                minimapCtx.beginPath();
                minimapCtx.arc(p.x * scale, p.y * scale, Math.max(2, p.radius * scale), 0, Math.PI * 2);
                minimapCtx.fillStyle = myPlayer && p.id === myPlayer.id ? '#00d4ff' : p.color;
                minimapCtx.fill();
            }

            minimapCtx.strokeStyle = 'rgba(255,255,255,0.5)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                (cameraX - canvas.width / 2 / cameraZoom) * scale,
                (cameraY - canvas.height / 2 / cameraZoom) * scale,
                (canvas.width / cameraZoom) * scale,
                (canvas.height / cameraZoom) * scale
            );
        }

        document.getElementById('playBtn').addEventListener('click', () => {
            startGame(document.getElementById('nameInput').value.trim());
        });
        document.getElementById('nameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') startGame(document.getElementById('nameInput').value.trim());
        });

        // Connect using SDK on load
        connect();
    </script>
</body>
</html>
