<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaos.io - Multiplayer Game Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a0a; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; }
        #gameCanvas { display: block; position: absolute; top: 0; left: 0; }

        /* Start Screen */
        #startScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }
        .logo {
            width: 120px; height: 120px; margin-bottom: 20px;
            filter: drop-shadow(0 0 30px rgba(0, 212, 255, 0.5));
        }
        .logo-text {
            font-size: 48px; font-weight: 900;
            background: linear-gradient(45deg, #00d4ff, #00ff88, #006080);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            margin-bottom: 10px; text-shadow: 0 0 60px rgba(0, 212, 255, 0.3);
        }
        .subtitle { color: #666; font-size: 16px; margin-bottom: 40px; }
        .input-container { display: flex; gap: 10px; margin-bottom: 20px; }
        #nameInput {
            padding: 15px 25px; font-size: 18px; border: 2px solid #333; border-radius: 50px;
            background: #1a1a1a; color: #fff; width: 250px; outline: none; transition: border-color 0.3s;
        }
        #nameInput:focus { border-color: #00d4ff; }
        #playBtn {
            padding: 15px 40px; font-size: 18px; font-weight: 600; border: none; border-radius: 50px;
            background: linear-gradient(45deg, #00d4ff, #00ff88); color: #000; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #playBtn:hover { transform: scale(1.05); box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4); }
        #playBtn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .server-status { color: #666; font-size: 14px; margin-bottom: 20px; }
        .server-status.connected { color: #00d4ff; }
        .server-status.error { color: #FF6B6B; }
        .instructions { color: #555; font-size: 14px; margin-top: 30px; text-align: center; line-height: 1.8; }
        .instructions kbd { background: #222; padding: 4px 8px; border-radius: 4px; font-family: monospace; }
        .powered-by { position: absolute; bottom: 30px; color: #333; font-size: 14px; }
        .powered-by a { color: #00d4ff; text-decoration: none; }

        /* HUD */
        #hud { position: fixed; top: 20px; left: 20px; color: #fff; font-size: 14px; z-index: 50; pointer-events: none; }
        .stat { background: rgba(0,0,0,0.5); padding: 8px 15px; border-radius: 20px; margin-bottom: 8px; backdrop-filter: blur(10px); }
        .stat-value { font-weight: 600; color: #00d4ff; }

        /* Leaderboard */
        #leaderboard {
            position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.6);
            padding: 15px 20px; border-radius: 15px; color: #fff; font-size: 14px;
            z-index: 50; min-width: 220px; backdrop-filter: blur(10px);
        }
        #leaderboard h3 { font-size: 16px; margin-bottom: 10px; color: #FFD700; }
        .lb-section { margin-bottom: 15px; }
        .lb-section-title { font-size: 12px; color: #888; margin-bottom: 5px; text-transform: uppercase; }
        .lb-entry { padding: 4px 0; display: flex; justify-content: space-between; }
        .lb-entry.me { color: #00d4ff; font-weight: 600; }
        .lb-rank { width: 25px; }
        .lb-name { flex: 1; overflow: hidden; text-overflow: ellipsis; }
        .lb-score { width: 60px; text-align: right; }
        .lb-kills { width: 40px; text-align: right; color: #FF6B6B; }

        /* Minimap */
        #minimap {
            position: fixed; bottom: 20px; right: 20px; width: 150px; height: 150px;
            background: rgba(0,0,0,0.5); border: 2px solid #333; border-radius: 10px; z-index: 50;
        }

        /* Messages */
        #messages { position: fixed; bottom: 20px; left: 20px; color: #fff; font-size: 14px; z-index: 50; }
        .message { background: rgba(0,0,0,0.5); padding: 8px 15px; border-radius: 10px; margin-top: 5px; animation: fadeIn 0.3s ease-out; }
        .message.kill { border-left: 3px solid #FF6B6B; }
        .message.info { border-left: 3px solid #4ECDC4; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <img src="logo.svg" alt="KaosNet" class="logo">
        <div class="logo-text">KAOS.IO</div>
        <div class="subtitle">Multiplayer Arena ‚Ä¢ Powered by KaosNet</div>
        <div class="server-status" id="serverStatus">Connecting to server...</div>
        <div class="input-container">
            <input type="text" id="nameInput" placeholder="Enter your name" maxlength="15" autofocus>
            <button id="playBtn" disabled>PLAY</button>
        </div>
        <div class="instructions">
            <strong>How to Play:</strong><br>
            Move your mouse to control direction<br>
            Eat food and smaller players to grow!<br><br>
            <strong>KaosNet Features:</strong> Leaderboards ‚Ä¢ Storage ‚Ä¢ Real-time Sync
        </div>
        <div class="powered-by">
            Powered by <a href="#">KaosNet</a> Game Server
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud" style="display: none;">
        <div class="stat">Score: <span class="stat-value" id="scoreValue">0</span></div>
        <div class="stat">High Score: <span class="stat-value" id="highScoreValue">0</span></div>
        <div class="stat">Kills: <span class="stat-value" id="killsValue">0</span></div>
        <div class="stat" style="font-size: 11px; opacity: 0.7;">
            Net: <span id="netStats">--</span>
        </div>
    </div>

    <!-- Leaderboard -->
    <div id="leaderboard" style="display: none;">
        <h3>üèÜ Leaderboard</h3>
        <div class="lb-section">
            <div class="lb-section-title">Current Game</div>
            <div id="currentLeaderboard"></div>
        </div>
        <div class="lb-section">
            <div class="lb-section-title">All-Time High Scores</div>
            <div id="allTimeLeaderboard"></div>
        </div>
    </div>

    <canvas id="minimap" style="display: none;"></canvas>
    <div id="messages"></div>

    <script>
        // Configuration
        const WS_URL = `ws://${window.location.hostname}:7351`;

        // Gaffer On Games networking constants
        const INTERPOLATION_DELAY = 100; // ms - buffer for smooth interpolation
        const PREDICTION_ENABLED = true;
        const INTERPOLATION_ENABLED = true;

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const minimapCtx = minimap.getContext('2d');

        // Game state from server
        let gameState = null;
        let myPlayerId = null;
        let playerName = 'Player';
        let ws = null;
        let connected = false;
        let mouseX = 0, mouseY = 0;
        let cameraX = 1000, cameraY = 1000, cameraZoom = 1;
        let messages = [];

        // === GAFFER ON GAMES: State Interpolation ===
        // Store snapshots for interpolation (ring buffer of server states)
        const stateBuffer = [];
        const STATE_BUFFER_SIZE = 20;

        // === GAFFER ON GAMES: Client-Side Prediction ===
        // Local predicted state for our player
        let predictedPlayer = null;
        let pendingInputs = []; // Inputs waiting for server confirmation
        let inputSequence = 0;

        // Interpolated positions for other players
        const interpolatedPlayers = new Map(); // playerId -> {x, y, radius, ...}

        // Server tick info for reconciliation
        let serverTick = 0;
        let lastProcessedInput = 0;

        // === Network stats tracking ===
        let lastServerUpdate = 0;
        let serverUpdateRate = 0;
        let updateCount = 0;
        let bytesReceived = 0;

        // === GAFFER ON GAMES: Quantization ===
        // Color palette for dequantizing food (matches server)
        const FOOD_COLORS = [
            "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7",
            "#DDA0DD", "#98D8C8", "#F7DC6F", "#BB8FCE", "#85C1E9",
        ];

        // Dequantize server state (handles both old and new format)
        function dequantizeState(raw) {
            // Check if this is quantized format (has 'q' scale factor)
            if (raw.q) {
                const scale = raw.q;
                return {
                    players: raw.p.map(p => ({
                        id: p.id,
                        name: p.name,
                        x: p.x / scale,
                        y: p.y / scale,
                        radius: p.r / scale,
                        color: p.color,
                        score: p.score,
                        high_score: p.high_score,
                        kills: p.kills
                    })),
                    food: raw.f.map(f => ({
                        id: f.id,
                        x: f.x / scale,
                        y: f.y / scale,
                        radius: f.r / scale,
                        color: FOOD_COLORS[f.c] || FOOD_COLORS[0]
                    })),
                    leaderboard: raw.lb,
                    world_width: raw.ww,
                    world_height: raw.wh,
                    tick: raw.t
                };
            }
            // Old format (unquantized) - pass through
            return raw;
        }

        // === GAFFER ON GAMES: State Snapshot Buffer ===
        // Buffer server states with timestamps for interpolation
        function bufferServerState(state) {
            const snapshot = {
                timestamp: performance.now(),
                serverTick: state.tick || serverTick++,
                players: state.players.map(p => ({...p})),
                food: state.food
            };

            stateBuffer.push(snapshot);

            // Keep buffer at fixed size
            while (stateBuffer.length > STATE_BUFFER_SIZE) {
                stateBuffer.shift();
            }
        }

        // === GAFFER ON GAMES: Server Reconciliation ===
        // When we receive server state, reconcile our predicted position
        function reconcileWithServer(serverState) {
            if (!PREDICTION_ENABLED || !myPlayerId) return;

            const serverPlayer = serverState.players.find(p => p.id === myPlayerId);
            if (!serverPlayer) return;

            // Get the server's last processed input sequence
            const serverInputSeq = serverState.last_input_seq || 0;

            // Remove inputs that the server has already processed
            pendingInputs = pendingInputs.filter(input => input.seq > serverInputSeq);

            // Start from server position
            if (predictedPlayer) {
                predictedPlayer.x = serverPlayer.x;
                predictedPlayer.y = serverPlayer.y;
                predictedPlayer.radius = serverPlayer.radius;
                predictedPlayer.score = serverPlayer.score;
                predictedPlayer.name = serverPlayer.name;
                predictedPlayer.color = serverPlayer.color;

                // Re-apply any inputs the server hasn't processed yet
                for (const input of pendingInputs) {
                    applyInput(predictedPlayer, input);
                }
            } else {
                // Initialize predicted player from server state
                predictedPlayer = {...serverPlayer};
            }
        }

        // Apply a single input to player state (for prediction replay)
        function applyInput(player, input) {
            if (!player) return;

            // Calculate movement direction
            const dx = input.target_x - player.x;
            const dy = input.target_y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 5) {
                // Speed decreases as player grows (same as server)
                const speed = Math.max(50, 200 - player.radius);
                const dt = input.dt || 0.05; // 50ms per input
                const moveX = (dx / dist) * speed * dt;
                const moveY = (dy / dist) * speed * dt;

                player.x += moveX;
                player.y += moveY;

                // Clamp to world bounds
                if (gameState) {
                    player.x = Math.max(player.radius, Math.min(gameState.world_width - player.radius, player.x));
                    player.y = Math.max(player.radius, Math.min(gameState.world_height - player.radius, player.y));
                }
            }
        }

        // === GAFFER ON GAMES: Entity Interpolation ===
        // Interpolate other players between server snapshots
        function interpolateEntities(renderTime) {
            if (!INTERPOLATION_ENABLED || stateBuffer.length < 2) return;

            // Find the two snapshots to interpolate between
            // We render in the past by INTERPOLATION_DELAY ms
            const targetTime = renderTime - INTERPOLATION_DELAY;

            let older = null;
            let newer = null;

            for (let i = 0; i < stateBuffer.length - 1; i++) {
                if (stateBuffer[i].timestamp <= targetTime &&
                    stateBuffer[i + 1].timestamp >= targetTime) {
                    older = stateBuffer[i];
                    newer = stateBuffer[i + 1];
                    break;
                }
            }

            // If we don't have valid snapshots, use latest
            if (!older || !newer) {
                const latest = stateBuffer[stateBuffer.length - 1];
                for (const player of latest.players) {
                    if (player.id !== myPlayerId) {
                        interpolatedPlayers.set(player.id, {...player});
                    }
                }
                return;
            }

            // Calculate interpolation factor (0 to 1)
            const range = newer.timestamp - older.timestamp;
            const t = range > 0 ? (targetTime - older.timestamp) / range : 0;
            const clampedT = Math.max(0, Math.min(1, t));

            // Interpolate each player
            for (const newerPlayer of newer.players) {
                if (newerPlayer.id === myPlayerId) continue; // Skip self

                const olderPlayer = older.players.find(p => p.id === newerPlayer.id);

                if (olderPlayer) {
                    // Lerp position
                    interpolatedPlayers.set(newerPlayer.id, {
                        ...newerPlayer,
                        x: olderPlayer.x + (newerPlayer.x - olderPlayer.x) * clampedT,
                        y: olderPlayer.y + (newerPlayer.y - olderPlayer.y) * clampedT,
                        radius: olderPlayer.radius + (newerPlayer.radius - olderPlayer.radius) * clampedT
                    });
                } else {
                    // New player, no interpolation
                    interpolatedPlayers.set(newerPlayer.id, {...newerPlayer});
                }
            }

            // Remove players that are no longer in the game
            const currentIds = new Set(newer.players.map(p => p.id));
            for (const id of interpolatedPlayers.keys()) {
                if (!currentIds.has(id)) {
                    interpolatedPlayers.delete(id);
                }
            }
        }

        // Get the rendered position for a player (uses prediction/interpolation)
        function getRenderedPlayer(player) {
            if (player.id === myPlayerId && PREDICTION_ENABLED && predictedPlayer) {
                // Use predicted position for self
                return predictedPlayer;
            } else if (player.id !== myPlayerId && INTERPOLATION_ENABLED) {
                // Use interpolated position for others
                return interpolatedPlayers.get(player.id) || player;
            }
            return player;
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // WebSocket connection
        function connect() {
            const statusEl = document.getElementById('serverStatus');
            const playBtn = document.getElementById('playBtn');

            statusEl.textContent = 'Connecting to server...';
            statusEl.className = 'server-status';

            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                connected = true;
                statusEl.textContent = '‚úì Connected to KaosNet server';
                statusEl.className = 'server-status connected';
                playBtn.disabled = false;
            };

            ws.onmessage = async (event) => {
                try {
                    // Handle both text and binary (Blob) messages
                    let data = event.data;
                    if (data instanceof Blob) {
                        bytesReceived += data.size;
                        data = await data.text();
                    } else {
                        bytesReceived += data.length;
                    }
                    const rawState = JSON.parse(data);

                    // === GAFFER ON GAMES: Dequantize state ===
                    // Server sends quantized ints to save bandwidth
                    gameState = dequantizeState(rawState);

                    // Track network stats
                    const now = performance.now();
                    if (lastServerUpdate > 0) {
                        const delta = now - lastServerUpdate;
                        serverUpdateRate = 0.9 * serverUpdateRate + 0.1 * (1000 / delta);
                    }
                    lastServerUpdate = now;
                    updateCount++;

                    // Find my player (first connection = first player for this client)
                    if (myPlayerId === null && gameState.players.length > 0) {
                        // We'll set this when we join
                    }

                    // === GAFFER ON GAMES: Buffer state for interpolation ===
                    bufferServerState(gameState);

                    // === GAFFER ON GAMES: Reconcile prediction with server ===
                    reconcileWithServer(gameState);
                } catch (e) {
                    console.error('Parse error:', e);
                }
            };

            ws.onclose = () => {
                connected = false;
                statusEl.textContent = 'Disconnected. Reconnecting...';
                statusEl.className = 'server-status error';
                playBtn.disabled = true;
                setTimeout(connect, 2000);
            };

            ws.onerror = () => {
                statusEl.textContent = 'Connection failed. Retrying...';
                statusEl.className = 'server-status error';
            };
        }

        // Start game
        function startGame(name) {
            playerName = name || 'Player';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('leaderboard').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';

            // The server assigns player ID on connection
            // We'll identify ourselves by being the newest player
            if (gameState && gameState.players.length > 0) {
                myPlayerId = gameState.players[gameState.players.length - 1].id;
            }

            addMessage('Welcome to Kaos.io!', 'info');
            addMessage('Eat food and smaller players to grow', 'info');

            requestAnimationFrame(gameLoop);
        }

        // Send input to server
        function sendInput() {
            if (!ws || ws.readyState !== WebSocket.OPEN || !gameState) return;

            const myPlayer = getMyPlayer();
            if (!myPlayer) return;

            // Convert screen mouse to world coordinates
            const targetX = cameraX + (mouseX - canvas.width / 2) / cameraZoom;
            const targetY = cameraY + (mouseY - canvas.height / 2) / cameraZoom;

            // === GAFFER ON GAMES: Track input for client-side prediction ===
            const input = {
                seq: ++inputSequence,
                target_x: targetX,
                target_y: targetY,
                dt: 0.05, // 50ms per input tick
                timestamp: performance.now()
            };

            // Store for server reconciliation
            if (PREDICTION_ENABLED) {
                pendingInputs.push(input);

                // Limit pending inputs buffer (discard old ones)
                while (pendingInputs.length > 60) {
                    pendingInputs.shift();
                }

                // Apply input locally for immediate response
                if (predictedPlayer) {
                    applyInput(predictedPlayer, input);
                }
            }

            ws.send(JSON.stringify({
                seq: input.seq,
                target_x: targetX,
                target_y: targetY,
                name: playerName
            }));
        }

        function getMyPlayer() {
            if (!gameState) return null;
            // Find player with highest ID (most recently joined = us)
            if (myPlayerId) {
                return gameState.players.find(p => p.id === myPlayerId);
            }
            return gameState.players[gameState.players.length - 1];
        }

        // Messages
        function addMessage(text, type = 'info') {
            messages.push({ text, type, time: Date.now() });
            if (messages.length > 5) messages.shift();
            updateMessagesUI();
        }

        function updateMessagesUI() {
            const container = document.getElementById('messages');
            container.innerHTML = messages
                .filter(m => Date.now() - m.time < 5000)
                .map(m => `<div class="message ${m.type}">${m.text}</div>`)
                .join('');
        }

        // Update leaderboard UI
        function updateLeaderboard() {
            if (!gameState) return;

            // Current game leaderboard
            const currentSorted = [...gameState.players].sort((a, b) => b.score - a.score).slice(0, 5);
            const currentList = document.getElementById('currentLeaderboard');
            const myPlayer = getMyPlayer();
            currentList.innerHTML = currentSorted.map((p, i) => {
                const isMe = myPlayer && p.id === myPlayer.id;
                return `<div class="lb-entry ${isMe ? 'me' : ''}">
                    <span class="lb-rank">${i + 1}.</span>
                    <span class="lb-name">${p.name}</span>
                    <span class="lb-score">${p.score}</span>
                </div>`;
            }).join('');

            // All-time leaderboard from server
            const allTimeList = document.getElementById('allTimeLeaderboard');
            if (gameState.leaderboard && gameState.leaderboard.length > 0) {
                allTimeList.innerHTML = gameState.leaderboard.slice(0, 5).map(entry => {
                    return `<div class="lb-entry">
                        <span class="lb-rank">${entry.rank}.</span>
                        <span class="lb-name">${entry.name}</span>
                        <span class="lb-score">${entry.score}</span>
                        <span class="lb-kills">‚öî${entry.kills}</span>
                    </div>`;
                }).join('');
            } else {
                allTimeList.innerHTML = '<div style="color:#555">No records yet</div>';
            }
        }

        // Update HUD
        function updateHUD() {
            const myPlayer = getMyPlayer();
            if (myPlayer) {
                // Use predicted score if available
                const displayPlayer = PREDICTION_ENABLED && predictedPlayer ? predictedPlayer : myPlayer;
                document.getElementById('scoreValue').textContent = displayPlayer.score;
                document.getElementById('highScoreValue').textContent = myPlayer.high_score;
                document.getElementById('killsValue').textContent = myPlayer.kills;
            }

            // Update network stats
            const kbReceived = (bytesReceived / 1024).toFixed(1);
            const pendingCount = pendingInputs.length;
            const bufferSize = stateBuffer.length;
            document.getElementById('netStats').textContent =
                `${serverUpdateRate.toFixed(0)}Hz | ${kbReceived}KB | P:${pendingCount} B:${bufferSize}`;
        }

        // Mouse handling
        canvas.addEventListener('mousemove', (e) => { mouseX = e.clientX; mouseY = e.clientY; });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        });

        // Game loop
        let lastTime = performance.now();
        let inputTimer = 0;

        function gameLoop(currentTime) {
            const dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Send input periodically
            inputTimer += dt;
            if (inputTimer > 0.05) { // 20 times per second
                sendInput();
                inputTimer = 0;
            }

            // === GAFFER ON GAMES: Interpolate other entities ===
            interpolateEntities(currentTime);

            // Update camera to follow player (use predicted position for responsiveness)
            const myPlayer = getMyPlayer();
            const cameraTarget = PREDICTION_ENABLED && predictedPlayer ? predictedPlayer : myPlayer;
            if (cameraTarget && gameState) {
                cameraX += (cameraTarget.x - cameraX) * 0.1;
                cameraY += (cameraTarget.y - cameraY) * 0.1;
                cameraZoom = Math.max(0.5, 1 - (cameraTarget.radius - 20) / 200);
            }

            render();
            renderMinimap();
            updateHUD();
            updateLeaderboard();

            requestAnimationFrame(gameLoop);
        }

        // Render
        function render() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!gameState) {
                ctx.fillStyle = '#333';
                ctx.font = '24px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Waiting for server...', canvas.width / 2, canvas.height / 2);
                return;
            }

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(cameraZoom, cameraZoom);
            ctx.translate(-cameraX, -cameraY);

            const worldWidth = gameState.world_width;
            const worldHeight = gameState.world_height;

            // Draw grid
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let x = 0; x <= worldWidth; x += 50) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, worldHeight); ctx.stroke();
            }
            for (let y = 0; y <= worldHeight; y += 50) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(worldWidth, y); ctx.stroke();
            }

            // Draw border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, worldWidth, worldHeight);

            // Draw food
            for (const f of gameState.food) {
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
                ctx.fillStyle = f.color;
                ctx.fill();
            }

            // Draw players (smallest first)
            // === GAFFER ON GAMES: Use rendered positions (predicted/interpolated) ===
            const sortedPlayers = [...gameState.players]
                .map(p => getRenderedPlayer(p))
                .sort((a, b) => a.radius - b.radius);
            const myPlayer = getMyPlayer();

            for (const p of sortedPlayers) {
                // Glow
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius * 1.2);
                gradient.addColorStop(0, p.color);
                gradient.addColorStop(0.8, p.color);
                gradient.addColorStop(1, 'transparent');
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * 1.1, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Body
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();

                // Border (highlight self)
                ctx.strokeStyle = myPlayer && p.id === myPlayer.id ? '#fff' : 'rgba(255,255,255,0.3)';
                ctx.lineWidth = myPlayer && p.id === myPlayer.id ? 4 : 2;
                ctx.stroke();

                // Name
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${Math.max(14, p.radius / 2)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.name, p.x, p.y - 5);

                // Score
                ctx.font = `${Math.max(10, p.radius / 3)}px sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.fillText(p.score, p.x, p.y + p.radius / 4);
            }

            ctx.restore();
        }

        // Minimap
        function renderMinimap() {
            if (!gameState) return;

            const mmWidth = 150, mmHeight = 150;
            minimap.width = mmWidth;
            minimap.height = mmHeight;

            minimapCtx.fillStyle = 'rgba(0,0,0,0.5)';
            minimapCtx.fillRect(0, 0, mmWidth, mmHeight);

            const scale = mmWidth / gameState.world_width;
            const myPlayer = getMyPlayer();

            // === GAFFER ON GAMES: Use rendered positions for minimap too ===
            for (const serverPlayer of gameState.players) {
                const p = getRenderedPlayer(serverPlayer);
                minimapCtx.beginPath();
                minimapCtx.arc(p.x * scale, p.y * scale, Math.max(2, p.radius * scale), 0, Math.PI * 2);
                minimapCtx.fillStyle = myPlayer && p.id === myPlayer.id ? '#00d4ff' : p.color;
                minimapCtx.fill();
            }

            // Viewport
            minimapCtx.strokeStyle = 'rgba(255,255,255,0.5)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                (cameraX - canvas.width / 2 / cameraZoom) * scale,
                (cameraY - canvas.height / 2 / cameraZoom) * scale,
                (canvas.width / cameraZoom) * scale,
                (canvas.height / cameraZoom) * scale
            );
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            startGame(document.getElementById('nameInput').value.trim());
        });
        document.getElementById('nameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') startGame(document.getElementById('nameInput').value.trim());
        });

        // Connect on load
        connect();
    </script>
</body>
</html>
